# 暑期集训做题记录

在暑期集训以及集训完的假期中，我完成了 _7.22vjudge_
专题训练的大部分题目，和在 _51nod_ 算法网站上做了160道左右的题目，
和对多项式的一些知识进行了系统地学习。下面就这些做过题目做一下整理和相应题目简单的报告.
以及自己对多项式相关算法的理解。


* ### 51nod
51nod将题目根据难度进行了分类，从基础题，一级题目到九级题目，和难题，
除了难题，其他级别或多或少做了一些题目，接下来按照级别对题目做一些整理

* ##### 基础题(42/42)

基础题大部分题目都比较基础，其中涉及到的一些算法和知识点有
* 数论中的 *gcd* *lcm* *中国剩余定理* *质数检测* *乘法逆元* *莫比乌斯函数* *原根* *欧拉函数* 等
* 经典问题 *bash游戏* *nim游戏* *约瑟夫环* *威佐夫游戏* 
* 简单的计算几何 *线段相交* *圆与三角形相交* *四点共面*
* 图论中的 *最小生成树* *最短路问题* 
* 常用算法 *最长公共子序列* *最长递增子序列* *最长回文子串* *快速幂* 以及 *矩阵快速幂*
因为题目较为简单，所以不一一列举列举出来，就选几道比较有代表性的题目讲讲

* 1183 编辑距离
> 编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数
许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。例如将kitten一字转成sitting:  
sitten （k->s）  
sittin （e->i）  
sitting （->g）  
所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。
给出两个字符串a,b，求a和b的编辑距离

简单的dp,dp[i][j]表示a串的前i位和b串的前j位的编辑距离，则
``` cpp
if(a[i]==b[j])dp[i][j]=dp[i-1][j-1];
else dp[i][j]=Min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1;
```

* 1185 威佐夫游戏V2
>有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。
例如：2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。  
数据规模：1<=n<=10^18

如果b = a + int ((1 + sqrt(5))/2 * (b-a))后手必胜，否则先手必胜。  
因为n可大至10^18，所以用double精度不够，这题用java水过

* 1298 圆与三角形
>给出圆的圆心和半径，以及三角形的三个顶点，问圆同三角形是否相交。相交输出"Yes"，否则输出"No"。（三角形的面积大于0）。

一步一步仔细算，防止溢出和精度问题就行

* 1459 迷宫游戏
>你来到一个迷宫前。该迷宫由若干个房间组成，每个房间都有一个得分，第一次进入这个房间，你就可以得到这个分数。还有若干双向道路连结这些房间，你沿着这些道路从一个房间走到另外一个房间需要一些时间。游戏规定了你的起点和终点房间，你首要目标是从起点尽快到达终点，在满足首要目标的前提下，使得你的得分总和尽可能大。现在问题来了，给定房间、道路、分数、起点和终点等全部信息，你能计算在尽快离开迷宫的前提下，你的最大得分是多少么？

最短路问题，dijkstra拓展，维护一个maxScore数组，在路径最短的情况下选择分数最大的
```cpp
void  Dijkstra(int dist[][maxn],int lowc[],int maxScore[],int n,int start){
    for(int i=0;i<n;i++){
        lowc[i]=INF; vis[i]=false; pre[i]=-1;
        maxScore[i]=0;
    }
    lowc[start]=0;
    maxScore[start]=score[start];
    for(int j=0;j<n;j++){
        int k=-1;
        int minc=INF;
        int maxs=0;
        for(int i=0;i<n;i++){
            if(!vis[i]&&(minc>lowc[i]||
                (minc==lowc[i]&&(maxs<maxScore[i])))){
                maxs=maxScore[i];
                minc=lowc[i];
                k=i;
            }
        }
        if(k==-1) break;
        vis[k]=true;
        for(int i=0;i<n;i++){
            if(!vis[i]&&(lowc[i]>lowc[k]+dist[k][i]||
                (lowc[i]==lowc[k]+dist[k][i]&&maxScore[i]<maxScore[k]+score[i]))){
                lowc[i]=lowc[k]+dist[k][i];
                maxScore[i]=maxScore[k]+score[i];
                pre[i]=k;
            }
        }
    }
}
```
* 1019 逆序数
>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。
如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。给出一个整数序列，求该序列的逆序数。

归并排序，在每次归并的时候统计逆序数
```cpp
void merge(int *a,int *b,int l,int r){
    int mid=(l+r)/2;
    int i=l,k=l,j=mid+1;
    while(i<=mid&&j<=r){
        if(a[i]<=a[j]) b[k++]=a[i++];
        else{
            b[k++]=a[j++];
            count+=(mid-i+1);
        }
    }
    while(i<=mid) b[k++]=a[i++];
    while(j<=r) b[k++]=a[j++];
}
```

* ##### 一级算法题(20/20)
一级算法题目还是一些比较基础的题目，所以还是值挑几道有代表性的题目

* 1003 阶乘后面0的数量
事实上就是统计*n!*中有多个5的因子，因为10=2*5，而2的因子数量远远多于5

* 1009 数字1的数量
>给定一个十进制正整数N，写下从1开始，到N的所有正数，计算出其中出现所有1的个数。
例如：n = 12，包含了5个1。1,10,12共包含3个1，11包含2个1，总共5个1。

数位dp,比较简单

* 1090 3个数和为0
>给出一个长度为N的无序数组，数组中的元素为整数，有正有负包括0，并互不相等。  
从中找出所有和 = 0的3个数的组合。如果没有这样的组合，输出No Solution。  
如果有多个，按照3个数中最小的数从小到大排序，如果最小的数相等则按照第二小的数排序。 
数据规模: 0<=n<=1000

51nod评测机很快，靠读入优化和输出优化，O(n^3)冲过去了

* 1289 大鱼吃小鱼
>有N条鱼每条鱼的位置及大小均不同，他们沿着X轴游动，有的向左，有的向右。游动的速度是一样的，两条鱼相遇大鱼会吃掉小鱼。  
从左到右给出每条鱼的大小和游动的方向（0表示向左，1表示向右）。问足够长的时间之后，能剩下多少条鱼？

单调栈，从左到右和从右到左扫一遍，分别计算左边的大鱼能吃掉多少条右边的鱼，再计算右边的大鱼能吃掉多少左边的小鱼。

* 1381 硬币游戏
>有一个简单但是很有趣的游戏。在这个游戏中有一个硬币还有一张桌子，这张桌子上有很多平行线（如下图所示）。两条相邻平行线之间的距离是1，硬币的半径是R，然后我们来抛硬币到桌子上，抛下之后硬币有时候会和一些直线相交（相切的情况也算是相交），有时候不会。
请你来计算一下抛一次硬币之后，该硬币和直线相交数目的期望。

D=2*R，找到一个数字L，满足
在抛硬币的时候，只需要考虑硬币落在的区间即可。

小圆一直向上移动，下边缘从0移动到1，中间过程中下边缘处于(0,L+1-D)时圆与L条直线相交，其它时刻与L+1条直线相交。
于是，期望为(L+1-D)*L+(D-L)*(L+1)=D

```python
t=int(input())
for i in range(t):
    print(2*int(input()))
```

* ##### 二级算法题(27/27)

* 1007 正整数分组
>将一堆正整数分为2组，要求2组的和相差最小。
例如：1 2 3 4 5，将1 2 4分为1组，3 5分为1组，两组和相差1，是所有方案中相差最少的。

类似差值dp的思想，dp[i][j]表示取前i个数，差值为j是否可能做到
```cpp
dp[now][0]=true;
for(int i=0;i<n;i++){
    cin>>x;
    for(int j=0;j<=10000;j++){
        dp[now^1][j]=false;
    }
    for(int j=0;j<=10000;j++){  
        if(dp[now][j]){
            if(j>=x) dp[now^1][j-x]=true;
            else dp[now^1][x-j]=true;
            if(j+x<=10000) dp[now^1][j+x]=true;
        }
    }
    now^=1;
}
```
* 1010 只包含因子2 3 5的数
>K的因子中只包含2 3 5。满足条件的前10个数是：2,3,4,5,6,8,9,10,12,15。
所有这样的K组成了一个序列S，现在给出一个数n，求S中 >= 给定数的最小的数。
例如：n = 13，S中 >= 13的最小的数是15，所以输出15。

把所有满足要求的数算出来，二分查找就行

* 1024 矩阵中不重复的元素
>一个m*n的矩阵。
该矩阵的第一列是a^b,(a+1)^b,.....(a + n - 1)^b  
第二列是a^(b+1),(a+1)^(b+1),.....(a + n - 1)^(b+1)  
.......  
第m列是a^(b + m - 1),(a+1)^(b + m - 1),.....(a + n - 1)^(b + m - 1)  
(a^b表示a的b次方）  
下面是一个4*4的矩阵：  
2^2=4, 2^3=8, 2^4=16, 2^5=32  
3^2=9, 3^3=27, 3^4=81, 3^5=243  
4^2=16, 4^3=64, 4^4=256, 4^5=1024  
5^2=25, 5^3=125, 5^4=625, 5^5=3125  
问这个矩阵里有多少不重复的数（比如4^3 = 8^2，这样的话就有重复了)  
2^2=4, 2^3=8, 2^4=16, 2^5=32  
3^2=9, 3^3=27, 3^4=81, 3^5=243  
4^2=16, 4^3=64, 4^4=256, 4^5=1024  
m = 4, n = 3, a = 2, b = 2。  
其中2^4与4^2是重复的元素。 

因为数据规模不大，考虑把所有的数算出来任意模三个数，用set判重

* 1031 1031 骨牌覆盖
>在2*N的一个长方形方格中，用一个1*2的骨牌排满方格。
问有多少种不同的排列方法。

找到递推式子，实际上是斐波拉契数列，快速幂就可

* 1042 数字0-9的数量
>给出一段区间a-b，统计这个区间内0-9出现的次数。比如 10-19，1出现11次（10,11,12,13,14,15,16,17,18,19,其中11包括2个1)，其余数字各出现1次。
简单的数位dp

* 1050 循环数组最大子段和
>N个整数组成的循环序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续的子段和的最大值（循环序列是指n个数围成一个圈，因此需要考虑a[n-1],a[n],a[1],a[2]这样的序列）。当所给的整数均为负数时和为0。
例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。

把循环数组当成非循环数组来算， 所取子段和不取子段构成原子段，若所取子段不超出边界，按照一般方法计算即可,否则不取子段不超出边界，
计算七最小值即可，用总和减去则得到最大子段和

* 1094 和为k的连续区间
>一整数数列a1, a2, ... , an（有正有负），以及另一个整数k，求一个区间[i, j]，(1 <= i <= j <= n)，使得a[i] + ... + a[j] = k。
双指针前后扫一遍

* 1095 Anigram单词
>一个单词a如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的Anigram，例如单词army和mary互为Anigram。现在给定一个字典，输入Q个单词，从给出的字典中找出这些单词的Anigram。

hash一下用set判重

* 1119 机器人走方格 V2
>M * N的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？由于方法数量可能很大，只需要输出Mod 10^9 + 7的结果。

结果是C(m+n,m)

* 1279 扔盘子
>有一口井，井的高度为N，每隔1个单位它的宽度有变化。现在从井口往下面扔圆盘，如果圆盘的宽度大于井在某个高度的宽度，则圆盘被卡住（恰好等于的话会下去）。
盘子有几种命运：1、掉到井底。2、被卡住。3、落到别的盘子上方。
盘子的高度也是单位高度。给定井的宽度和每个盘子的宽度，求最终落到井内的盘子数量。

扔一个盘子，从井底往井口开始考虑是否能放，只需要从井底到井口遍历一遍就行了。这时候要预处理一下井口的宽度。
就是上面有比底下面小的宽度。那么按上述做法是不对的。那么就要保证井底到井口的宽度是递增(相邻之间宽度相等也是 允许的)。

* 1315 合法整数集
>一个整数集合S是合法的，指S的任意子集subS有Fun（SubS）！=X，其中X是一个固定整数，Fun(A)的定义如下：
A为一个整数集合，设A中有n个元素，分别为a0，a1，a2,...,an-1,那么定义：Fun(A)=a0 or a1 or ... or an-1；Fun({}) = 0,即空集的函数值为0.其中，or为或操作。
现在给你一个集合Y与整数X的值，问在集合Y至少删除多少个元素能使集合Y合法？
例如：Y = {1,2,4}，X=7；显然现在的Y不合法，因为 1 or 2 or 4 = 7，但是删除掉任何一个元素后Y将合法。所以，答案是1.

把x为0的位不为0的y排除掉， 这些y中1最少的位的1的个数就是

* 1413 权势二进制
>一个十进制整数被叫做权势二进制，当他的十进制表示的时候只由0或1组成。例如0，1，101，110011都是权势二进制而2，12，900不是。
当给定一个n的时候，计算一下最少要多少个权势二进制相加才能得到n。

找到数位中最大的那个数字即可

* 1428 活动安排问题
有若干个活动，第i个开始时间和结束时间是[Si,fi)，同一个教室安排的活动之间不能交叠，求要安排所有活动，最少需要几个教室？ 

按照结束时间排序，优先队列

* 1432 独木舟
>n个人，已知每个人体重。独木舟承重固定，每只独木舟最多坐两个人，可以坐一个人或者两个人。显然要求总重量不超过独木舟承重，假设每个人体重也不超过独木舟承重，问最少需要几只独木舟？

题目要求每个人体重都不超过船重量，可以先预处理超过船重量的这些人。 然后将小于船重量的人进行升序排序。。然后枚举最大重量即可（贪心）。

* 1489 蜥蜴和地下室
>哈利喜欢玩角色扮演的电脑游戏《蜥蜴和地下室》。此时，他正在扮演一个魔术师。在最后一关，他必须和一排的弓箭手战斗。他唯一能消灭他们的办法是一个火球咒语。如果哈利用他的火球咒语攻击第i个弓箭手（他们从左到右标记），这个弓箭手会失去a点生命值。同时，这个咒语使与第i个弓箭手左右相邻的弓箭手（如果存在）分别失去b(1 ≤ b < a ≤ 10)点生命值。
因为两个端点的弓箭手（即标记为1和n的弓箭手）与你相隔较远，所以火球不能直接攻击他们。但是哈利能用他的火球攻击其他任何弓箭手。
每个弓箭手的生命值都已知。当一个弓箭手的生命值小于0时，这个弓箭手会死亡。请求出哈利杀死所有的敌人所需使用的最少的火球数。
如果弓箭手已经死亡，哈利仍旧可以将他的火球扔向这个弓箭手。
数据规模: 3<=n<=10

打爆头尾后dfs

* 1629 B君的圆锥
>B君要用一个表面积为S的圆锥将白山云包起来。  
B君希望包住的白山云体积尽量大，B君想知道体积最大可以是多少。  
注意圆锥的表面积包括底面和侧面。

计算题，结果是S^3/(72*Pi)

* ##### 三级算法题(40/40)

* 1013 3的幂的和
>求：3^0 + 3^1 +...+ 3^(N) mod 1000000007

等比数列求和以后求逆就行

* 1021 石子归并
>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。
例如： 1 2 3 4，有不少合并方法  
1 2 3 4 => 3 3 4(3) => 6 4(9) => 10(19)  
1 2 3 4 => 1 5 4(5) => 1 9(14) => 10(24)  
1 2 3 4 => 1 2 7(7) => 3 7(10) => 10(20)  
括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。

dp[i][j],表示从i到j这段归并得到的最大值

* 1035 最长的循环节
>正整数k的倒数1/k，写为10进制的小数如果为无限循环小数，则存在一个循环节，求<=n的数中，倒数循环节长度最长的那个数。
1/6= 0.1(6) 循环节长度为1  
1/7= 0.(142857) 循环节长度为6  
1/9= 0.(1)  循环节长度为1 
数据规模:10<=n<1000 

问题等价于求满足方程10^m=1(modk)的最小的m  
数据规模不大，可以直接求解

* 1043 幸运号码
>1个长度为2N的数，如果左边N个数的和 = 右边N个数的和，那么就是一个幸运号码。
例如：99、1230、123312是幸运号码。
给出一个N，求长度为2N的幸运号码的数量。由于数量很大，输出数量 Mod 10^9 + 7的结果即可。

dp[i][j]表示长度为i位，总和为j的组合的数量,注意排除前导0的情况

* 1065 最小正子段和
>N个整数组成的序列a[1],a[2],a[3],…,a[n]，从中选出一个子序列（a[i],a[i+1],…a[j]），使这个子序列的和>0，并且这个和是所有和>0的子序列中最小的。
例如：4，-1，5，-2，-1，2，6，-2。-1，5，-2，-1，序列和为1，是最小的。

先求一下从第一位开始的到第i位的累加，  
4，-1，5，-2，-1，2，6，-2 => 4 3 8 6 5 7 13 11  
对这个累加的数列排个序，然后只要判断邻近的两个数是否可以组成序列，比如4和3就不可以，因为4 > 3而4对应下标为0,3对应为1。4和5就可以  

* 1068 Bash游戏 V3
>有一堆石子共有N个。A B两个人轮流拿，A先拿。每次拿的数量只能是2的正整数次幂，比如(1,2,4,8,16....)，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N，问最后谁能赢得比赛。
例如N = 3。A只能拿1颗或2颗，所以B可以拿到最后1颗石子。（输入的N可能为大数）

找规律，总和为3的倍数的时候B胜

* 1096 距离之和最小
>X轴上有N个点，求X轴上一点使它到这N个点的距离之和最小，输出这个最小的距离之和。

找中位数即可

* 1097 拼成最小的数
>设有n个正整数，将它们联接成一排，组成一个最小的多位整数。  
例如：  
n=2时，2个整数32，321连接成的最小整数为：32132，  
n=4时，4个整数55，31，312, 33 联接成的最小整数为：312313355  
 
交换相邻两个串a,b会使答案变差当且仅当a+b<b+a,拍个序即可
```cpp
bool operator<(const Number& rhs)const{
    string tmp1=str+rhs.str;
    string tmp2=rhs.str+str;
    return tmp1<tmp2;
}
```

* 1098 最小方差
>若x1,x2,x3......xn的平均数为k。  
则方差s^2 = 1/n * [(x1-k)^2+(x2-k)^2+.......+(xn-k)^2] 。  
方差即偏离平方的均值，称为标准差或均方差，方差描述波动程度。  
给出M个数，从中找出N个数，使这N个数方差最小。  

将所有的数从小到大排序，方差最小的N个数在这里里面一定是连续，遍历一遍即可

* 1101 换零钱
>N元钱换为零钱，有多少不同的换法？币值包括1 2 5分，1 2 5角，1 2 5 10 20 50 100元。  
例如：5分钱换为零钱，有以下4种换法：  
1、5个1分  
2、1个2分3个1分  
3、2个2分1个1分  
4、1个5分  
(由于结果可能会很大，输出Mod 10^9 + 7的结果)  

简单dp
```cpp
dp[0]=1;
for(int i=0;i<13;i++){
    for(int j=arr[i];j<=n;j++){
       dp[j]=(dp[j]+dp[j-arr[i]])%mod;
    }
}
```
* 1102 面积最大的矩形
>有一个正整数的数组，化为直方图，求此直方图包含的最大矩形面积。  

单调栈，求出每个矩形左边和右边高度第一个比它低的。

* 1163 最高的奖励
>有N个任务，每个任务有一个最晚结束时间以及一个对应的奖励。在结束时间之前完成该任务，就可以获得对应的奖励。
完成每一个任务所需的时间都是1个单位时间。有时候完成所有任务是不可能的，因为时间上可能会有冲突，这需要你来取舍。求能够获得的最高奖励。

按结束时间排序，优先队列求解


* 1246 罐子和硬币
>有n个罐子，有k个硬币，每个罐子可以容纳任意数量的硬币。罐子是不透明的，你可以把这k个硬币任意分配到罐子里。
然后罐子被打乱顺序，你从外表无法区别罐子。最后罐子被编上号1-n。每次你可以询问某个罐子，
如果该罐子里有硬币，则你可以得到1个（但你不知道该罐子中还有多少硬币），如果该罐子是空的，你得不到任何硬币，
但会消耗1次询问的机会。你最终要得到至少c枚硬币（c<=k),
问题是给定n,k,c，由你来选择一种分配方式，使得在最坏情况下，询问的次数最少，求这个最少的次数。  
例如：有3个罐子，10个硬币，需要得到7个硬币，(n = 3, k = 10, c = 7)。  
你可以将硬币分配为：3 3 4，然后对于每个罐子询问2次，可以得到6个硬币，再随便询问一个罐子，就可以得到7个硬币了。  

刚开始想的是尽量平均分，但经验证是不对的,我们需要将最少的空位找到，只要是最少的空位，询问的次数肯定是最少的，
特判一下c <= k/n*n这个的情况

* 1247 可能的路径
>在一个无限大的二维网格上，你站在(a,b)点上，下一步你可以移动到(a + b, b), (a, a + b), (a - b, b), 或者 (a, a - b)这4个点。
给出起点坐标(a,b)，以及终点坐标(x,y)，问你能否从起点移动到终点。如果可以，输出"Yes"，否则输出"No"。
例如：(1,1) 到 (2,3)，(1,1) -> (2,1) -> (2,3)。

和辗转相除法类似，如果(a,b)=(x,y),则是可以到达的

* 1267 4个数和为0
>给出N个整数，你来判断一下是否能够选出4个数，他们的和为0，可以则输出"Yes"，否则输出"No"。

4-sum问题，枚举所有的二元组，然后二分查找

* 1268 和为K的组合
>给出N个正整数组成的数组A，求能否从中选出若干个，使他们的和为K。如果可以，输出："Yes"，否则输出"No"。
数据规模：2<=n<=20

除了暴力，没有什么比较好的办法

* 1270 数组的最大代价
>数组A包含N个元素A1, A2......AN。数组B包含N个元素B1, B2......BN。并且数组A中的每一个元素Ai，都满足1 <= Ai <= Bi。数组A的代价定义为
所有两个相邻元素的差的绝对值之和。给出数组B，计算可能的最大代价S。

当数组A具有最大价值时，Ai要么取1，要么取Bi,然后dp就行

* 1272 最大距离
>给出一个长度为N的整数数组A，对于每一个数组元素，如果他后面存在大于等于该元素的数，则这两个数可以组成一对。每个元素和自己也可以组成一对。例如：{5, 3, 6, 3, 4, 2}，可以组成11对，如下（数字为下标）：
(0,0), (0, 2), (1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (3, 3), (3, 4), (4, 4), (5, 5)。其中(1, 4)是距离最大的一对，距离为3。

从前往后维护一个单减栈，每一个新值去栈里二分查
```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=50010;
int a[maxn];

int main(){
    vector<int>q;
    int n;
    cin>>n;
    int ans=0;
    for(int i=0;i<n;i++){
        cin>>a[i];
        if(q.size()==0||a[q.back()]>a[i]){
            q.push_back(i);
        }else{
            int l=0,r=q.size()-1;
            while(r-l>1){
                int mid=(l+r)/2;
                if(a[q[mid]]<=a[i]) r=mid;
                else l=mid;
            }
            if(a[q[l]]<=a[i]) r=l;
            ans=max(ans,i-q[r]);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
* 1276 岛屿的数量
>有N个岛连在一起形成了一个大的岛屿，如果海平面上升超过某些岛的高度时，则这个岛会被淹没。原本的大岛屿则会分为多个小岛屿，
如果海平面一直上升，则所有岛都会被淹没在水下。  
给出N个岛的高度。然后有Q个查询，每个查询给出一个海平面的高度H，问当海平面高度达到H时，海上共有多少个岛屿。例如：  
岛屿的高度为：{2, 1, 3, 2,4, 3}, 查询为：{0, 1, 3, 2}。  
当海面高度为0时，所有的岛形成了1个岛屿。  
当海面高度为1时，岛1会被淹没，总共有2个岛屿{2} {3, 2, 3}。  
当海面高度为3时，所有岛都会被淹没，总共0个岛屿。  
当海面高度为2时，岛0, 1, 3会被淹没，总共有2个岛屿{3} {3}。  

每淹没一个峰值点，岛屿数量减1，每淹没一个谷值点，岛屿数量加1。拍个序遍历一遍即可。

* 1285 山峰和分段
>用一个长度为N的整数数组A，描述山峰和山谷的高度。山峰需要满足如下条件， 
0 < P < N - 1 且 A[P - 1] < A[P] > A[P + 1]。  
现在要将整个山分为K段，要求每段的点数都一样，且每段中都至少存在一个山峰，问最多可以分为多少段。

分段前后的每段的山峰的数量不会变化，计算一个前缀和，分解因数扫一遍即可。

* 1352 集合计数
>给出N个固定集合{1，N},{2,N-1},{3,N-2},...,{N-1,2},{N,1}.求出有多少个集合满足：第一个元素是A的倍数且第二个元素是B的倍数。

扩展欧几里得

* 1393 0和1相等串
>给定一个0-1串，请找到一个尽可能长的子串，其中包含的0与1的个数相等。

计算前缀和,0的时候以-1来计算，前缀和相同是统计一下

* 1396 还是01串
>给定一个0-1串s，长度为n，下标从0开始，求一个位置k，满足0<=k<=n, 并且子串s[0..k - 1]中的0的个数与子串s[k..n - 1]中1的个数相等。 注意：  
（1） 如果k = 0, s[0..k - 1]视为空串  
（2） 如果k = n, s[k..n - 1]视为空串  
（3） 如果存在多个k值，输处任何一个都可以  
（4） 如果不存在这样的k值，请输出-1

统计1的数量就是答案就是答案，很神奇

* 1402 最大值
>一个N长的数组s[](注意这里的数组初始下标设为1，而不是0，即N个元素为s[1],s[2],...,s[N])，满足以下性质：  
1）每个元素都是非负的整数，且s[1]=0；  
2）任意两个相邻元素差值的绝对值不大于1，即| s[i]-s[i+1] |<=1；  
3）对于部分特殊点xi，要求s[xi]<=ti（这样的特殊点一共M个）；  
问在以上约束下s[]中的最大值最大可能是多少？  

这个题最主要的是求出真正每个xi位置s[xi]能够取到的ti的最值，因此有以下二种情况  
1.存在  t[i] > t[i-1] + X[i] - X[i-1]  
2.存在  t[i] > t[i+1] + X[i + 1] - X[i]  
剩下的就是在两个特殊点中可能取到的最大值，既然是最大值则显然两个特殊点之间可能出现的只有是先增后减和一直增
于是可取点 x[t]位于xi和x[i+1]之间显然可得 s[Xt] - s[Xi] + s[Xt] - s[X[i+1]] <= X[i + 1] - X[i],  
于是可得 S[Xt] <= (S[X[i]] + S[X[i + 1]] + X[i+1]-X[i]) /2 ，显然最值是在S[Xi] = ti ，S[Xi+1] = t[i+1]的情况下取到的。
从前往后，从后往前刷新一下ti的值,再统计。

* 1414 冰雕
>白兰大学正在准备庆祝成立256周年。特别任命副校长来准备校园的装扮。  
校园的中心竖立着n个冰雕。这些雕像被排在一个等分圆上，因此他们形成了一个正n多边形。这些冰雕被顺针地从1到n编号。每一个雕有一个吸引力t[i].  
校长来看了之后表示不满意，他想再去掉几个雕像，但是剩下的雕像必须满足以下条件：  
· 剩下的雕像必须形成一个正多边形(点数必须在3到n之间，inclusive)，  
· 剩下的雕像的吸引力之和要最大化。  
请写一个程序帮助校长来计算出最大的吸引力之和。如果不能满足上述要求，所有雕像不能被移除。  

分解因数，依次判断一下

* 1416 两点
>福克斯在玩一款手机解迷游戏，这个游戏叫做”两点”。基础级别的时候是在一个n×m单元上玩的。   
每一个单元有包含一个有色点。我们将用不同的大写字母来表示不同的颜色。 
这个游戏的关键是要找出一个包含同一颜色的环。看上图中4个蓝点，形成了一个环。一般的，我们将一个序列 d1,d2,...,dk 看成一个环，
当且仅当它符合下列条件时：
1.这k个点不一样，即当 i≠j时， di 和 dj不同。  
2.k至少是4。  
3.所有的点是同一种颜色。  
4.对于所有的 1≤i≤k-1: di 和 di+1 是相邻的。还有 dk 和 d1 也应该相邻。单元 x 和单元 y 是相邻的当且仅当他们有公共边。  
当给出一幅格点时，请确定里面是否有环。  

dfs,搜索的时候需要记录上次走过的方向，不能走相同的方向

* 1418 放球游戏
>有N个球排成一排，每个球都是R、G、B三种颜色之一。现在想重新排列这一排球，你要重复以下过程N次：
1）从原来的那排球中的最左侧取出一个球；
2）将取出的求插入新的球排列的任意位置，即可以放在最左或最右端，也可以插入那排球的任意两个相邻球之间；
3）计算这轮得分，如果是第一个球那么得0分；如果放在两端（最左或最右端）得分为除了新放入的球外，剩余球的颜色种数；如果放在两个球之间，那么得分为这个新放入的球左侧所有球的颜色种数与这个球右侧所有球的颜色种数的和。（解释一下“颜色种数”：一堆球里出现的不同颜色个数，对应这里的得分就是一种颜色得一分，多个球同色只算一次得分。）
那么在最优操作下，最多能得到的总分是多少？

优先把颜色分为两组，每组各一个RGB，之后往中间放。贪心模拟。

* 1475 建设国家
>小C现在想建设一个国家。这个国家中有一个首都，然后有若干个中间站，还有若干个城市。
现在小C想把国家建造成这样的形状：选若干（可以是0个）的中间站把他们连成一条直线，然后把首都(首都也是一个中间站)连在这一条直线的左端。然后每个点可以连一个城市，特别的是最右端的点可以连接两个城市。
现在有n个城市的规划供小C选择。但是，他们那儿的交通条件比较差，他们那儿一天是2*H个小时，每个城市里面的人每天都会去首都拿一样东西，从他们所在的城市出发，到了首都之后拿了东西就走（拿东西的时间可以忽略不计），他们要在2*H个小时之内返回他们自己的家中（从家中出发到返回家中不超过2*H小时）。
每个城市有两个属性，一个是城市的直径，另外一个是能居住的人口数目。对于第i个城市而言，这两个属性分别是hi,pi。
城市的直径的意思是离这个城市出口最远的人想要出城先要在城里行走的最少的时间。
在首都，中间站，城市之间行走要花费1小时的时间。
小C想选择一些城市然后通过若干的中间站和首都连接起来，在每个人能在2*H小时返回的条件下所有城市居住的总人口数目要最多。

这个题目是一个非常好的贪心和有先队列的题目
将距离按照降序排列，然后在只有满足当前数量<i的时候往里面添加元素，弹出来的是当前队列中的人口最少的城市，
队列中的是被选中的满足接下来长度要求的城市，然后在这一轮中添加这个距离的所有城市，之后如果城市数量超出，
再将人口最少的城市排除。也就是说，队列里面是符合长度要求的人口最多且在当前状况下数量最多的城市

* 1625 夹克爷发红包
>在公司年会上，做为互联网巨头51nod掌门人的夹克老爷当然不会放过任何发红包的机会。
现场有n排m列观众，夹克老爷会为每一名观众送出普通现金红包，每个红包内金额随机。
接下来，夹克老爷又送出最多k组高级红包，每组高级红包会同时给一排或一列的人派发 ,每个高级红包的金额皆为x。
派发高级红包时，普通红包将会强制收回。同时，每个人只能得到一个高级红包。（好小气！）
现在求一种派发高级红包的策略，使得现场观众获得的红包总金额最大。
数据规模：1 <= n <= 10, 1 <= m <= 200 1<= x <= 10^9，0 <= k <= n + m

n比较小，所以可以枚举n排发放红包的所有情况,然后将每一列进行排序，选取得到红包最少的几列发放高级红包

* 1631 小鲨鱼在51nod小学
>鲨鱼巨巨2.0（以下简称小鲨鱼）以优异的成绩考入了51nod小学。并依靠算法方面的特长，在班里担任了许多职务。  
每一个职务都有一个起始时间A和结束时间B，意为小鲨鱼在[A, B]时间内，担任了某职务(inclusively)。  
现在给定小鲨鱼的职务履历表，你可以高效的给出小鲨鱼在某天担任了哪些职务吗？  
p.s. 由于小鲨鱼担任的职务太多，所有任期小于一个自然月的职务都忽略不计。（如1月1日~2月1日为一个自然月，即月份加1）  
p.p.s. 输入数据保证小鲨鱼同时不担任超过200种职务。（牛！）  
p.p.p.s 输入的日期均为合法日期，范围在2000年01月01日~2999年12月31日。  
p.p.p.p.s巨大的输入输出，推荐使用scanf/printf，编译器推荐使用Virtual C++  

题目本身不难，但如果给个年月日，要算出是2000年1月1日开始的第几日，比较麻烦还容易出错，一个简单的技巧是
直接令time=y*500+m*40+d, 保证了日期越靠前的越小，越靠后的数值越大 

* 1632 B君的连通
>B国拥有n个城市，其交通系统呈树状结构，即任意两个城市存在且仅存在一条交通线将其连接。
A国是B国的敌国企图秘密发射导弹打击B国的交通线，现假设每条交通线都有50%的概率被炸毁，
B国希望知道在被炸毁之后，剩下联通块的个数的期望是多少？

这题是马拉松16的题目，事实上答案就是(n+1)*2^(n-2)

* 1639 绑鞋带
>有n根鞋带混在一起，现在重复n次以下操作：随机抽出两个鞋带头，把它们绑在一起。可以想象，这n次之后將不再有单独的鞋带头，
n条鞋带系成了一些环。那么有多大概率刚好所有这些鞋带只形成了一个环？

概率dp
```cpp
dp[1]=1.0;
for(int k=1;k<n;k++){
    dp[k+1]=dp[k]*2.0*(n-k)/(2.0*(n-k)+1);
}
```

* 1640 天气晴朗的魔法
>51nod魔法学校近日开展了主题为“天气晴朗”的魔法交流活动。  
N名魔法师按阵法站好，之后选取N - 1条魔法链将所有魔法师的魔力连接起来，形成一个魔法阵。
魔法链是做法成功与否的关键。每一条魔法链都有一个魔力值V，魔法最终的效果取决于阵中所有魔法链的魔力值的和。
由于逆天改命的魔法过于暴力，所以我们要求阵中的魔法链的魔力值最大值尽可能的小，与此同时，魔力值之和要尽可能的大。
现在给定魔法师人数N，魔法链数目M。求此魔法阵的最大效果。

先用Kruskal 算出最大边的最小值,再用一下Kruskal算法算出最大生成数

* 1770 数数字
>统计aaa...aaa*b的结果里面有多少个数字d

分情况讨论，a*b如果是一位数很简单，如果是两位数，考虑是否进位

* ##### 四级算法题(13/72)

* 1051 最大子矩阵的和
>一个M*N的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的值。

思想就是将最大子矩阵的和转换为最大k数和，记录一下每一列的前缀和，然后转为最大k数和来做

* 1060 最复杂的数
>把一个数的约数个数定义为该数的复杂程度，给出一个n，求1-n中复杂程度最高的那个数。
例如：12的约数为：1 2 3 4 6 12，共6个数，所以12的复杂程度是6。如果有多个数复杂度相等，输出最小的。

事实上这个题是求反素数，反素数的定义是：对于任何正整数n,其约数个数记为f(n),例如f(6)=4,果某个正整数n满足：对任意的正整数i，
都有f(i)<f(n)，那么称n为反素数。  
反素数有两个性质:  
（1）一个反素数的所有质因子必然是从2开始的连续若干个质数，因为反素数是保证约数个数为x的这个数n尽量小  
(2)同样的道理，如果n=（2^t1）* (3^t2)...,那么必有t1>t2>t3>...
```python
def dfs(cur, num, deep, pre): #cur表示当前数，num表示当前约数数量，deep表示第几个素数，pre上一次的约数数量
    if deep>12:
        return
    global ans
    global div_num
    global n
    if num > div_num:
        ans = cur
        div_num = num
    elif num == div_num and cur < ans:
        ans = cur
    for i in range(1, pre+1):
        cur *= prime[deep]
        if cur <= n:
            dfs(cur, num*(i+1), deep + 1, i)
        else:
            break
```

* 1108 距离之和最小 V2
>三维空间上有N个点, 求一个点使它到这N个点的曼哈顿距离之和最小，输出这个最小的距离之和。
点(x1,y1,z1)到(x2,y2,z2)的曼哈顿距离就是|x1-x2| + |y1-y2| + |z1-z2|。即3维坐标差的绝对值之和。

x,y,z坐标其实没有什么关系，分别计算就行了

* 1109 01组成的N的倍数
>给定一个自然数N，找出一个M，使得M > 0且M是N的倍数，并且M的10进制表示只包含0或1。求最小的M。
数据规模：1<=N<=10^6

v1版本数据规模不大，可以枚举二进制位

* 1110 距离之和最小 V3
>X轴上有N个点，每个点除了包括一个位置数据X[i]，还包括一个权值W[i]。该点到其他点的带权距离 = 实际距离 * 权值。
求X轴上一点使它到这N个点的带权距离之和最小，输出这个最小的带权距离之和。

这里可以吧w[i]看做是w[i]个点，然后转换位普通的距离之和最小的问题

* 1179 最大的最大公约数
>给出N个正整数，找出N个数两两之间最大公约数的最大值。例如：N = 4，4个数为：9 15 25 16，两两之间最大公约数的最大值是15同25的最大公约数5。 

可以考虑质数筛法的原理，枚举1-N，然后统计有多少个数能被这个数整除,找到最大的这个数就是答案

* 1186 质数检测 V2
>给出1个正整数N，检测N是否为质数。如果是，输出"Yes"，否则输出"No"。
数据规模: 2<=N<=10^30

这个题是 miller_rabin算法，miller_rabin算法的原理就是找一个数p不是素数的证据，而miller_rabin算法,
经过证明，证据有超过50%, 所以如果随机测试50个数，可以使测试失败的概率降低到非常非常低。
N非常大，C++即使用__int128也会溢出，所以需要高精度。

* 1419 最小公倍数挑战
>几天以前，我学习了最小公倍数。玩得挺久了，想换换口味。
我不想用太多的数字，我想从1到n中选三个数字（可以相同）。使得他们的最小公倍数最大。

构造题
```cpp
if(n<=2) cout<<n<<endl;
else if(n%2){
    cout<<n*(n-1)*(n-2)<<endl;
}else if(n%3){
    cout<<n*(n-1)*(n-3)<<endl;
}else{
    cout<<(n-1)*(n-2)*(n-3)<<endl;
}
```

* 1491 黄金系统
>q=(sqrt(5)+1)/2,在黄金系统下，a0a1...an等于sigma(ai*q^(n-i)),其中ai=0或ai=1
现在给出两个黄金系统下面的数字，请比较他们的大小。

类于两个其他进制数字的比较，n位数字的最大值为(1-q^n)/(1-q)<q^(n+2),因此从高位比较道低位，
设置一个阙值10,如果大于了10直接给出判断,跳出循环

* 1605 棋盘问题
>上帝创造了一个n*m棋盘，每一个格子都只有可能是黑色或者白色的。
亚当和夏娃在玩一个游戏，每次寻找边长为x的正方形，其中每个格子必须为黑色，然后将这些格子染白。
如果谁不能操作了，那么那个人就输了。
亚当喜欢质数。
夏娃喜欢1，但讨厌2。
因此他们规定，x只有可能是非2质数或者是1。
现在他们想知道，如果他们都用最优策略进行游戏，谁会赢。
上帝规定亚当先手。

x一定为奇数，x*x也为奇数，所以最终结论是所有黑色格子总数，若为奇数则yadang胜，否则xiawa胜

* 1607 卷积和
>杰西最近在研究卷积，例如一个数字1234，那么经过杰西的变换后，就会变成1*4+2*3+3*2+4*1，例如一个数字是234，那么就会变成2*4+3*3+4*2。
形象化的，我们可以设f(x)表示x经过杰西变换后的值。如果他想知道对于所有i=L~R时的f(i)的值的和，该怎么做呢。
现在这个问题交给了你。但是这个答案可能会非常大，因此杰西只想知道最终答案对1000000007取模后的答案。

非常烦的一道数位dp。利用卷积公式的的一些性质入手，降低位数，然后迭代。

* ##### 五级算法题(8/98)

* 1020 逆序排列
>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。  
如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。  
1-n的全排列中，逆序数最小为0（正序），最大为n*(n-1) / 2（倒序）  
给出2个数n和k，求1-n的全排列中，逆序数为k的排列有多少种？  

设f(n,k)表示n个数的排列中逆序数个数为k的排列数。
最大的数n可能会排在第n-i位，从而产生i个与n有关的逆序对，
去掉n之后，剩下的n-1个数的排列有k-i个逆序对。所以，f(n,k)=sigma(f(n-1，k-i))(0<=i<n)。
同理有f(n,k-1)=sigma(f(n-1，k-1-i))(0<=i<n)。
两式相减，可得f(n,k)-f(n,k-1)=f(n-1,k)-f(n-1,k-n)。
从而f(n,k)=f(n,k-1)+f(n-1,k)-f(n-1,k-n)。

* 1020 大数乘法V2
>给出2个大整数A,B，计算A*B的结果。
(A,B的长度 <= 100000，A,B >= 0）

长度非常大，必须采用nlgn的方法，把两个十进制数表示成多项式的形式，采用快速傅里叶变化来解决多项式乘法

* 1040 最大公约数之和
>给出一个n，求1-n这n个数，同n的最大公约数的和。比如：n = 6
1,2,3,4,5,6 同6的最大公约数分别为1,2,3,2,1,6，加在一起 = 15

通过一系列的证明和化简，最终答案是sigma(d*phi(n/d),其中d|n,分解n然后计算，计算phi的时候可以先打一个1-1e6
的表，然后剩余的欧拉函数单个暴力来求

* 1120 机器人走方格 V3
>N * N的方格，从左上到右下画一条线。一个机器人从左上走到右下，只能向右或向下走。并要求只能在这条线的上面或下面走，不能穿越这条线，有多少种不同的走法？
由于方法数量可能很大，只需要输出Mod 10007的结果。

卡特兰数加卢卡斯定理的应用，答案是2*C(2n,n)/(n+1)

* 1161 Partial Sums
>给出一个数组A，经过一次处理，生成一个数组S，数组S中的每个值相当于数组A的累加，比如：A = {1 3 5 6} => S = {1 4 9 15}。如果对生成的数组S再进行一次累加操作，
{1 4 9 15} => {1 5 14 29}，现在给出数组A，问进行K次操作后的结果。(每次累加后的结果 mod 10^9 + 7)

考虑每个位置的贡献，所求ans[n]=sigma(C(k-1+i,i)*a[j])(i+j=n),上述卷积形式可以利用FFT或NTT加速运算，难点在于答案模
10^9+7,设其为P,这意味这参与卷积的每个元素值为不大于(P-1)的非负整数，卷积后的值为不大于(n+1)*(p-1)^2,这个上界可以达到
5*10^22.想法是利用3种模意义下的NTT结果进行合并，得到这个可能达到 5⋅10^22 的数，再取模，一共需要9次NTT，涉及高精度。

* 1496 最小异或和
>一个集合包含一组相互不同的数字。现在我们要去寻找一个集合，他要满足如下性质：
对于所有 x(x∈S)，要满足l≤x≤r;
1≤|S|≤k;
设S中第i个元素是 si;那么 f(S)=s1⨁s2⨁...⨁s|S|的值要尽可能小。

|S|=1时，选择l, |S|=2，选择相邻的两个数，x^(x+1)=1,其中x%2==0,  
|S|=4,选择4个数 x^(x+1)^(x+2)^(x+3),其中 x%2==0,  
|S|=3时，考虑一种构造使得得到0这个结果，   
设三个数分别为x,y,z并且 x>y>z ,那么可以在二进制位中调整x,z的值，使x,y,z的值相对接近
如 110000 
   101111
   011111
